function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var jsdom = require('jsdom');
var css = _interopDefault(require('css'));
var path = _interopDefault(require('path'));
var prettyBytes = _interopDefault(require('pretty-bytes'));
var sources = _interopDefault(require('webpack-sources'));

function createDocument(html) {
    var jsdom$$1 = new jsdom.JSDOM(html, {
        contentType: 'text/html'
    });
    var window = jsdom$$1.window;
    var document = window.document;
    document.$jsdom = jsdom$$1;
    return document;
}

function serializeDocument(document) {
    return document.$jsdom.serialize();
}

function parseStylesheet(stylesheet) {
    return css.parse(stylesheet);
}

function serializeStylesheet(ast, options) {
    return css.stringify(ast, options);
}

function walkStyleRules(node, iterator) {
    if (node.stylesheet) 
        { return walkStyleRules(node.stylesheet, iterator); }
    node.rules = node.rules.filter(function (rule) {
        if (rule.rules) {
            walkStyleRules(rule, iterator);
        }
        return iterator(rule) !== false;
    });
}

function tap(inst, hook, pluginName, async, callback) {
    if (inst.hooks) {
        var camel = hook.replace(/-([a-z])/g, function (s, i) { return i.toUpperCase(); });
        inst.hooks[camel][async ? 'tapAsync' : 'tap'](pluginName, callback);
    } else {
        inst.plugin(hook, callback);
    }
}

var PLUGIN_NAME = 'critters-webpack-plugin';
var Critters = function Critters(options) {
    this.options = options || {};
    this.urlFilter = this.options.filter;
    if (this.urlFilter instanceof RegExp) {
        this.urlFilter = this.urlFilter.test.bind(this.urlFilter);
    }
};
Critters.prototype.apply = function apply (compiler) {
        var this$1 = this;

    tap(compiler, 'compilation', PLUGIN_NAME, false, function (compilation) {
        if (compilation.hooks.htmlWebpackPluginAfterHtmlProcessing) {
            tap(compilation, 'html-webpack-plugin-after-html-processing', PLUGIN_NAME, true, function (htmlPluginData, callback) {
                this$1.process(compiler, compilation, htmlPluginData.html).then(function (html) {
                    callback(null, {
                        html: html
                    });
                }).catch(callback);
            });
        } else {
            tap(compilation, 'optimize-assets', PLUGIN_NAME, true, function (assets, callback) {
                var htmlAssetName;
                for (var name in assets) {
                    if (name.match(/\.html$/)) {
                        htmlAssetName = name;
                        break;
                    }
                }
                if (!htmlAssetName) 
                    { return callback(Error('Could not find HTML asset.')); }
                var html = assets[htmlAssetName].source();
                if (!html) 
                    { return callback(Error('Empty HTML asset.')); }
                this$1.process(compiler, compilation, String(html)).then(function (html) {
                    assets[htmlAssetName] = new sources.RawSource(html);
                    callback();
                }).catch(callback);
            });
        }
    });
};
Critters.prototype.readFile = function readFile (filename, encoding) {
        var this$1 = this;

    return new Promise(function (resolve, reject) {
        this$1.fs.readFile(filename, encoding, function (err, data) {
            if (err) 
                { reject(err); }
             else 
                { resolve(data); }
        });
    });
};
Critters.prototype.process = function process (compiler, compilation, html) {
    return new Promise((function ($return, $error) {
            var this$1 = this;

        var outputPath, document, styles;
        outputPath = compiler.options.output.path;
        document = createDocument(html);
        if (this.options.external !== false) {
            var externalSheets;
            externalSheets = [].slice.call(document.querySelectorAll('link[rel="stylesheet"]'));
            return Promise.all(externalSheets.map(function (link) { return this$1.embedLinkedStylesheet(link, compilation, outputPath); })).then((function ($await_4) {
                try {
                    return $If_3.call(this);
                } catch ($boundEx) {
                    return $error($boundEx);
                }
            }).bind(this), $error);
        }
        function $If_3() {
                var this$1 = this;

            styles = [].slice.call(document.querySelectorAll('style'));
            return Promise.all(styles.map(function (style) { return this$1.processStyle(style, document); })).then(function ($await_5) {
                try {
                    return $return(serializeDocument(document));
                } catch ($boundEx) {
                    return $error($boundEx);
                }
            }, $error);
        }
            
        return $If_3.call(this);
    }).bind(this));
};
Critters.prototype.embedLinkedStylesheet = function embedLinkedStylesheet (link, compilation, outputPath) {
    return new Promise((function ($return, $error) {
        var href, media, document, preloadMode, filename, asset, sheet, cssLoaderPreamble, lazy, style, noscriptFallback;
        href = link.getAttribute('href');
        media = link.getAttribute('media');
        document = link.ownerDocument;
        preloadMode = this.options.preload;
        if (this.urlFilter ? this.urlFilter(href) : href.match(/^(https?:)?\/\//)) 
            { return $return(Promise.resolve()); }
        filename = path.resolve(outputPath, href.replace(/^\//, ''));
        asset = compilation.assets[path.relative(outputPath, filename).replace(/^\.\//, '')];
        return new Promise((function ($return, $error) {
            if (asset) 
                { return $return(asset.source()); }
            return this.readFile(filename, 'utf8').then($return, $error);
        }).bind(this)).then((function ($await_7) {
            try {
                sheet = $await_7;
                cssLoaderPreamble = "function $loadcss(u,m,l){(l=document.createElement('link')).rel='stylesheet';l.href=u;document.head.appendChild(l)}";
                lazy = preloadMode === 'js-lazy';
                if (lazy) {
                    cssLoaderPreamble = cssLoaderPreamble.replace('l.href', "l.media='only x';l.onload=function(){l.media=m};l.href");
                }
                style = document.createElement('style');
                style.appendChild(document.createTextNode(sheet));
                link.parentNode.insertBefore(style, link.nextSibling);
                style.$$name = href;
                if (preloadMode === false) 
                    { return $return(); }
                noscriptFallback = false;
                if (preloadMode === 'body') {
                    document.body.appendChild(link);
                } else {
                    link.setAttribute('rel', 'preload');
                    link.setAttribute('as', 'style');
                    if (preloadMode === 'js' || preloadMode === 'js-lazy') {
                        var script;
                        script = document.createElement('script');
                        var js;
                        js = cssLoaderPreamble + "$loadcss(" + (JSON.stringify(href)) + (lazy ? ',' + JSON.stringify(media || 'all') : '') + ")";
                        script.appendChild(document.createTextNode(js));
                        link.parentNode.insertBefore(script, link.nextSibling);
                        cssLoaderPreamble = '';
                        noscriptFallback = true;
                    } else if (preloadMode === 'media') {
                        link.setAttribute('rel', 'stylesheet');
                        link.removeAttribute('as');
                        link.setAttribute('media', 'only x');
                        link.setAttribute('onload', ("this.media='" + (media || 'all') + "'"));
                        noscriptFallback = true;
                    } else if (preloadMode === 'swap') {
                        link.setAttribute('onload', "this.rel='stylesheet'");
                        noscriptFallback = true;
                    } else {
                        var bodyLink;
                        bodyLink = document.createElement('link');
                        bodyLink.setAttribute('rel', 'stylesheet');
                        if (media) 
                            { bodyLink.setAttribute('media', media); }
                        bodyLink.setAttribute('href', href);
                        document.body.appendChild(bodyLink);
                    }
                }
                if (this.options.noscriptFallback !== false && noscriptFallback) {
                    var noscript;
                    noscript = document.createElement('noscript');
                    var noscriptLink;
                    noscriptLink = document.createElement('link');
                    noscriptLink.setAttribute('rel', 'stylesheet');
                    noscriptLink.setAttribute('href', href);
                    if (media) 
                        { noscriptLink.setAttribute('media', media); }
                    noscript.appendChild(noscriptLink);
                    link.parentNode.insertBefore(noscript, link.nextSibling);
                }
                return $return();
            } catch ($boundEx) {
                return $error($boundEx);
            }
        }).bind(this), $error);
    }).bind(this));
};
Critters.prototype.processStyle = function processStyle (style) {
    return new Promise((function ($return, $error) {
        var options = this.options;
        var document = style.ownerDocument;
        var head = document.querySelector('head');
        var sheet = style.childNodes.length > 0 && [].map.call(style.childNodes, function (node) { return node.nodeValue; }).join('\n');
        var before = sheet;
        if (!sheet) 
            { return $return(); }
        var ast = parseStylesheet(sheet);
        var criticalFonts = '';
        var failedSelectors = [];
        walkStyleRules(ast, function (rule) {
            if (rule.type === 'rule') {
                rule.selectors = rule.selectors.filter(function (sel) {
                    sel = sel.replace(/::?(?:[a-z-]+)([.[#~&^:*]|\s|\n|$)/gi, '$1').trim();
                    try {
                        return document.querySelector(sel) != null;
                    } catch (e) {
                        failedSelectors.push(sel + ' -> ' + e.message);
                        return null;
                    }
                });
                if (rule.selectors.length === 0) {
                    return false;
                }
                if (rule.declarations) {
                    for (var i = 0;i < rule.declarations.length; i++) {
                        var decl = rule.declarations[i];
                        if (decl.property.match(/\bfont\b/i)) {
                            criticalFonts += ' ' + decl.value;
                        }
                    }
                }
            }
            if (rule.type === 'font-face') 
                { return; }
            return !rule.rules || rule.rules.length !== 0;
        });
        if (failedSelectors.length !== 0) {
            console.warn((failedSelectors.length) + " rules skipped due to selector errors:\n  " + failedSelectors.join('\n  '));
        }
        var shouldPreloadFonts = options.fonts === true || options.preloadFonts === true;
        var shouldInlineFonts = options.fonts !== false || options.inlineFonts === true;
        var preloadedFonts = [];
        walkStyleRules(ast, function (rule) {
            if (rule.type !== 'font-face') 
                { return; }
            var family, src;
            for (var i = 0;i < rule.declarations.length; i++) {
                var decl = rule.declarations[i];
                if (decl.property === 'src') {
                    src = (decl.value.match(/url\s*\(\s*(['"]?)(.+?)\1\s*\)/) || [])[2];
                } else if (decl.property === 'font-family') {
                    family = decl.value;
                }
            }
            if (src && shouldPreloadFonts && preloadedFonts.indexOf(src) === -1) {
                preloadedFonts.push(src);
                var preload = document.createElement('link');
                preload.setAttribute('rel', 'preload');
                preload.setAttribute('as', 'font');
                if (src.match(/:\/\//)) {
                    preload.setAttribute('crossorigin', 'anonymous');
                }
                preload.setAttribute('href', src.trim());
                head.appendChild(preload);
            }
            if (!family || !src || criticalFonts.indexOf(family) === -1 || !shouldInlineFonts) 
                { return false; }
        });
        sheet = serializeStylesheet(ast, {
            compress: this.options.compress !== false
        });
        if (sheet.trim().length === 0) {
            if (style.parentNode) {
                style.parentNode.removeChild(style);
            }
        } else {
            while (style.lastChild) {
                style.removeChild(style.lastChild);
            }
            style.appendChild(document.createTextNode(sheet));
        }
        var name = style.$$name ? style.$$name.replace(/^\//, '') : 'inline CSS';
        var percent = sheet.length / before.length * 100 | 0;
        console.log('\u001b[32mCritters: inlined ' + prettyBytes(sheet.length) + ' (' + percent + '% of original ' + prettyBytes(before.length) + ') of ' + name + '.\u001b[39m');
        return $return();
    }).bind(this));
};

module.exports = Critters;
//# sourceMappingURL=critters.js.map
